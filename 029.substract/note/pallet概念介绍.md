简单看一下 pallet，有个印象，
- 了解 substrate 的架构？
- pallet 的层次？

substraet-node-template 的目录命名方式和 substrate 的分层概念很贴近。
```
├── Cargo.lock
├── Cargo.toml
├── LICENSE
├── README.md
├── docker-compose.yml
├── docs
├── node
├── pallets
├── runtime
├── rustfmt.toml
├── scripts
├── shell.nix
└── target
```

- node: node 层里可以填写一些配置，控制生成最后的可执行二进制文件
- pallets: runtime 的最小单元，目前 pallets 里面提供了一个 template 示例，演示如何写 pallets
- runtime: 所有的 pallet 组装成 runtime 的逻辑代码。

利用 substrate 定制自己的区块链，就是整个区块链的业务逻辑最主要就是写不同的 pallets。

首先可以看到 pallets 里面有各种各样的宏

```rust
#![cfg_attr(not(feature = "std"), no_std)]

pub use pallet::*;

#[cfg(test)]
mod mock;

#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

#[frame_support::pallet]
pub mod pallet {
	use frame_support::pallet_prelude::*;
	use frame_system::pallet_prelude::*;

	#[pallet::config]
	pub trait Config: frame_system::Config {
		type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;
	}

	#[pallet::pallet]
	#[pallet::generate_store(pub(super) trait Store)]
	pub struct Pallet<T>(_);

	#[pallet::storage]
	#[pallet::getter(fn something)]
	pub type Something<T> = StorageValue<_, u32>;

	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
		SomethingStored(u32, T::AccountId),
	}

	#[pallet::error]
	pub enum Error<T> {
		NoneValue,
		StorageOverflow,
	}

	#[pallet::call]
	impl<T: Config> Pallet<T> {
		#[pallet::weight(10_000 + T::DbWeight::get().writes(1))]
		pub fn do_something(origin: OriginFor<T>, something: u32) -> DispatchResult {
			let who = ensure_signed(origin)?;
			<Something<T>>::put(something);
			Self::deposit_event(Event::SomethingStored(something, who));
			Ok(())
		}

		#[pallet::weight(10_000 + T::DbWeight::get().reads_writes(1,1))]
		pub fn cause_error(origin: OriginFor<T>) -> DispatchResult {
			let _who = ensure_signed(origin)?;

			match <Something<T>>::get() {
				None => Err(Error::<T>::NoneValue)?,
				Some(old) => {
					let new = old.checked_add(1).ok_or(Error::<T>::StorageOverflow)?;
					<Something<T>>::put(new);
					Ok(())
				},
			}
		}
	}
}
```
注意看这里
```rust
#[frame_support::pallet]
pub mod pallet {
    // 1. 先写配置 config
    #[pallet::config]
    pub trait Config: frame_system::Config {}
    // 2. 声明存储 storage
    #[pallet::storage]
	 #[pallet::getter(fn something)]
	 pub type Something<T> = StorageValue<_, u32>;
	 // 3. public function (user-callabled) 用户可调用的公共方法
	 // 4. private function
	 // 5. 声明事件 event
	 // 6. 自定义 error，public function 调用失败的返回
}
```
都需要在这个里面声明一个pald的猫就然后呢，并且能要配上这个framesport的palts。然后呢，在拍了成猫，就里面的，我们分三个部分分几个部分？首先呢？如果说。写过智能合约的同学呢，对这个就很不陌生了，首先呢，比如说我，我们要写一些配置。然后呢，其次呢，我们要申明一些存储。再其次呢，我们要申明一些public方式，然后呢，travit方神。那么public方式呢？也就是说是用户可调用的方法，我们叫public方式。private方式呢，就是说用户不可调用的方法。那么呢啊，这个呢？是通常是一个合约的架构啊，然后其次呢？再声明啊，一本声明事件。
然后呢，在这里面呢，你还可以多生了一个error，可以制定一个error就说如果说你的这个public方式如果调用失败了。他会给你返回一个error，你会很清楚的知道说你为什么会失败，那就类似于啊智能合约里面的愉快啊失败的情况。的报错这个呢就是说一个pallet的结构就你声明。你的存储，然后呢，上面用户可调用的方法上面一些帮助方法写一写一些prep，preb方式。然后呢，第11本子和艾瑞，基本上你这个拍了就已经写完了，那么呢，这就是一个拍了的的架构。那么呢，他基本上每一个，其中每一个组件呢？我们都会用一个红。都会用一个主要的红去进行声明，那么这个主要的红呢在无论是在初节课和进节课都不会展开说这个红干了什么事情。我们只需要会用这个拍了这款肺给就可以了，比如说在声明肯肺给的时候呢，那么这个就是一个很经典的rust的写法，就是我在。在这里呢，我申明一些肯肺格，并且呢，这些肯肺格呢是一些粘的我的肯肺格。也就是说，我在这个里面呢，我只设只声明一些抽象类型。然后呢，之后呢，我会带大家来写一个例子，然后呢，大家就。知道说这个肯费格是，呃，就是究竟是什么样的作用因为确实。这个东西呢？我说是名配置呢。确实比较难理解。然后呢？pallet然后呢？这个呢？是所有pallet。就必须要写的，就是说申明一个，就是申明一个struct拍了然后呢，下面呢就是说这边的是我们第一单单独第一存储的地方。
那么呢，对于每一个成组呢，我们都用拍了的storage红去对他进行修饰。然后呢，在这边拍了theget那么呢这边呢？就是说是会给下面的这个。存储呢？会定义一个快捷定义一个get方法，然后呢，可以看到这个存储的类型叫商品，然后呢？它存的是一个值类型。是一个u32的职类型，他的一本才是声明声明一个一本。然后呢，这个上面一个事件，然后通过这两个红，就是，大家只要照样写就可以了，然后呢，上面一个事件。然后呢，这个事件呢，就是发送发送一个伤心到的，那么很很明显的就是说大家猜一猜这个逻辑呢，就说我把一个东西存在链上了，成成功之后呢。我只发一个事件叫相亲stod，然后呢，通过这个palleterror来声明是明error上就当baliostuageoverflow，那也就是说可能是说我曾失败的，或者茶失败了。我就会报一个error然后呢拍了次靠呢这个呢只相当于我们说的那些publicfunction。那么能在在三岁里面呢，我们把它把所有的pub的方方式呢。叫disposable放生可调可调用的方法。然后呢，我们这个还是一个很经典的rust写法，然后呢，我们可以看到大概我们就是这堂课呢，就是我们不深入任何具体的rust。啊或者是说这个红。我们只说带大家把这个东西呢先看一遍看一遍之后呢，大家有这么个印象。
就是比如说一个pallet，它的大概的架构是怎么样的？就ok了，在这里呢，就是不需要大家会写，因为之后的四节课呢就是带大家去写这个东西的。然后呢，我们大概看一下，比如说啊，比如说这个位置呢，就是说我调用这个方法需要花多少钱。那么一开始呢，我在这边制成零的，可以就是为了方方，为了方便我写零的，可以就相当于调用这方法，不要花钱。然后呢，就相信你可以看到说我首先呢会从这个熬弱症里面会得到说谁调谁调用了这个方法。然后呢，我就把这个桑不信就是比如说把它改成说我传进来的这个商品。然后呢，更新更新存储更新完存储呢我发送一个事件然后呢发送一个伤不清st的这个事件告诉外界说我这个东西存成功了，是谁存了什么值。上链然后呢？那么第二个方法呢？是说提供一个靠。coserror呢？我们先猜一猜啊，因为rust他难写但是他不难猜。嗯首先看呢他肯定显示去取了三不信这个值，然后呢，如果说没有取到呢？就直接报错告诉你说。嗯，没有这个值，如果如果能取到值呢？那就把它加一。如果说加，如果说加错了，比如说这个车可爱的，就比如说超过最大值了。那么，我依然会报这个storageoverflow这个错误，然后呢？如果说，既。既不是没有值，也没有overflow，那么呢，我就我就不要把这个新的值加一之后的质量。把它啊加一之后更新伤不起这个存储。
ok，这个就是一个就是虽然看着看着看着就是各种红，很花哨但是呢综合来看呢。他其实能只分这几个步骤，gener，con。fig，然后呢？存储，然后用户可调用的方法，用户不可调用方法。然后呢，电用成功了就发事件，电用失败了就发error在这堂课呢，确实说所有的红，大家就记得赵超就ok了。如果说大家想知道这些红干了就是就是比如这些红在背后都做了哪些事情呢。呃，教大家一个方法，就比如说我们可以看到这个templeter，他有一个对应的他的这个。猫主的配置文件，然后呢可以看到他的内幕叫pallettemplete，然后呢，我们有一个工具叫cargoexpend。然后呢，杠屁，杠屁呢，就是刚刚拍开这个缩写杠屁，然后呢，比如说拍了。汤普莱特，然后呢，我们把它写到汤普莱特。friend写到一个新的文件里面去，这个时候我们就可以看到，在我。在这个目录下生成了一个新的文件，叫tumptheexband。然后呢，我们就可以看到，额，这个文件呢就是说，我们把我们，我们把摊铺了它里面的这些红。展开之后，可以看到，这边他们来的总共只有110行，然后呢，我把这110行的。代码然后呢，把这么多红全部展开之后呢，得到的文件呢，就是长这个样子。然后呢，这个文件可以看到差不多呢，是说有1000多好，也就是说正因为有这些红的存在，然后呢帮助我们说不需要处不需要处理。
这些，比如说很底层的东西，我只需要聚焦于业务逻辑就ok了，他可以不？他可以帮我把1000多行的代码压缩到100多行。然后呢，并且能让我一个非常轻松的方式只聚焦于我的业务，然后呢，我们可以看到，在。他生成的这个1000多行的文件，里面的基本上就是说给我视频的拍了车去implit。各种各样的treat，然后呢，这些treat呢是便于说啊，就是底底层和底层交互的。
然后呢，我们来看。装time，装time呢，就是说我们把不同的拍了组装成，最终，我们所说的状态转换函数就是装time或者是frame的。那个地方可以看到，首先呢？我在这边呢？额，比如说，我想组装哪些pallet，我就把哪些拍了，他引入进来，然后呢。我们说了，每一个拍了的呢，一开始呢，我们看这个摊铺来着，一开始呢，我们说都需要去配置一些通用的。抽象的抽象类型，通用配置，然后呢，因为在这边定义的是抽象类型，所以呢，我们在真正组装的时候才给他复制。比如说，在真正组装的时候呢，我们才把它在这里生命的一些抽象类型所赋予。给他付具体的类型然后呢我们可以看到这边有framesister然后呢下面比如说拍了次orr拍了次果然的怕。然后下面还有palletbalances，我们能把这些具体的pallet引入进来之后呢，然后通过一个construct状态。这个红把这么多把这么多拍了的组装成。把它共同包装成一个状态，然后呢以一个整体和note，或者和靠层进行交互。然后呢，我觉得说。在这节课呢，我们就是不深入代码，就完全不深入代码。在这节课最后呢。我想说的主要就是这个詹多可能fig，因为写过智能合约的同学呢。对下面这几个点是很不很不陌生的，或者说写的代码同学都不陌生，唯独这个战斗很费个呢。他其实是跟rust的本身的特性是有点相关的。然后呢，我们举一个什么例子，让大家来很直观的理解这个config到底是什么东西呢。
我们举个例子，我们刚才说了，我们刚才说了这个额这个拍了。拍了车balancers这个呢是说就是。控制个人脱看余额的这么一个拍了。然后呢，我们想新加一个功能啊，就比如说我网恋，我网恋上存一个东西，比如说我在这里。我网恋上存一个东西的时候呢？我说就比如说我网恋上存东西呢？是需要成本的在这边呢？我在阿布在他之前呢。我需要他，呃，先交一笔钱，比如说有一个upct费吧。他需要先交一笔钱才能啊不对的，这个storage那么我怎么收这个那么我怎么收这个人的钱呢。那么通常意义上呢，就比如说我们说其他的，任何的，差不多任何项目呢的通用写法呢？是说我首先呢。因为呢，我要扣，我要扣这个钱，扣这个钱呢，我就需要扣这个钱呢，我就需要操作这个拍了车。搬了这这个模块，那么我要操作这个模块呢？我首先呢，就要先。引入这个依赖，那么呢，一般一般的做法是这样子的，就比如说我们随便复制一个，随便复制一个这个。我们比如说在这里呢，我们想我们新加一个依赖拍了车。额，balancers，然后呢，这边都是不变的，都是从subway里面去拉。这个balance然后呢，我们在这边在s，t，d里面。加上我们的拍了这个就ok了。这个呢大家完全不需要记，因为还是刚才强调过很多遍，我们后面会带大家一行一行的去写代码的。然后呢，在这边，我们说只是说从通用的，从通用工程的角度去理解这个confeat到底是个什么东西。
ok，那么呢，我最应该的，比如说我，这个时候呢，我引引入了拍了车。白了这次，然后呢。等一下，我看看他有没有自动更新，拍了。有没有写错拍了车八人行死拍了八人。拍了车balancers比如说啊拍了车这边大家就是完全不用写，就是看我感感受一下就可以了。就比如说在这边呢，我们说，我们需要让他交一笔钱，就是从他的个人账户上。付一笔费看一下。嗯哈了。
嗯，decreatebalance。然后呢，啊，decisbalance就从从从他的账户上扣一笔钱，那么从谁呢？从这个货。比如说扣多少呢？扣10万吧差不多。就比如说，如果说我们不配置这个。肯fig的话，那么呢，我，我们要实现这个目的呢，就是说在这个里面引入。拍了，在八点，就是这个依赖，然后呢，然后扣，然后扣一笔钱，我们把它试着编一下试试看。放屁，额，开了temple哦然后可以看到说他这边说不满足。这个t的砍到这衣服啊。他的promptt那么。
然后呢，就可以看到说他说，他说这个类型约束不满足。类型约束不满足的话，那么我们就不先这么用，也就是说我们为了让让他满足这个类型约束的话，那就是说我们再在这边，然后继承拍的死。巴勒车拍了车巴勒车是的很费格ok，那么这样子的话。这样这样子的话，他就知道他这个t的约束就已经满足了，因为我们。这个呢？加号呢，就类似于其他的语言里面的一个继承的概念，就是我这个时候。我这个摊不了他里面的config基记住了，frame，thestom也继承了啊，拍拍了这八两小时里面的config。然后呢，这边放的intiger，也就是说他这边呢可以看到他这边需要的类型的是说要传入self点balances。然后我们把这个换成，换成self点半了，才。然后再编译一遍，可以看到编译通过了，并通过呢？我们可以通过这种方式呢？说在引入拍了个balant的时候，在这边强行指定，说怎么样去扣这个钱。但是比如说但是，比如说假设说我这个店我不仅有单头肯，我，还有各种各样的其他的资产，就比如说我先扣先扣到。再扣其他的笔，再扣其他的笔，那么这个时候呢？我这边的很明显说很很很明显说我如果这么写的话，那我如果说之后的业务升级，或者是逻辑变更之后。我就需要处理非常非常多这样子因为引入具体的依赖而需要去处理的一些问题。
那么在这个时候呢，rust强大的抽象能力就体现出来了，这个时候我们在sub。j里面通常会怎么做。通常呢，我们在这边，我们不失明，不是不引入任何依赖，我们失明一个太。typecarracy他能继承的carracy这个trate额carriedtrate我记得应该是。应该是在啊对应该是在这个费用词，port这个trate然后呢。
这边大家先目前是完全不需要理解的。就是相当于说，我在这边说明了一个通用类型叫carracy，他符合这个carracytrate的通这个。约束，然后呢？我怎么办呢？然后呢？我在这边呢，我就不用指定这个排练车。balancis了，这个时候呢，我就会写，比如说tcurrency，然后呢，就比如说我在这个里面找一下一些降低余额的方法。比如说举个例子就实在是吧。实在是把这个户然后呢？比如说也。野山，一笔钱，然后呢，我们可以看到。在这在这种情况下我们通篇都没有出，呃，都没有出现任何palletbalancers这个。这个依赖，那么甚至这个时候呢，我可以把这个依赖从我的cargo里面给cargo配置里面给全部删掉。然后呢，我再编译，可以发现依然可以编译，通过。那么这个时候呢？那么这个时候我该怎么指定？就比如说我在在就上线的时候，我该怎么指定说我需要。扣什么样的偷肯呢？比如说是需要在哪边扣哪就在哪里扣哪种偷肯呢。那么这个时候呢？我就在组装这个状态的时候，这边可以看到会报错，他会提示，我说。有一个currency没有给他具体的实现类型，那么在这边我们把它补上开头currency。然后在这边呢，我们写拍了在balance或者我们一般。一般这么写也可以，因为下面呢，他组，他在组装状态的时候呢？其实。
这个白蓝色丝就是拍了白蓝色丝，然后能通过这样子的形式呢？我们会。可以看到，我们在这个里面呢，说既做到很，就是说如果说假设说我之后说我不用改，我不想跟我。完了这里面的钱了，比如说我想扣，比如说拍了车啊set里里面的钱。或者是说扣任何其他的钱，我只要在这边随便替换一行就ok了，我再也不需要说，比如说在。任何的拍了它里面去手动引路那个依赖，然后从而做到。拍了者和拍了之间形成调用或者是交互的这么一个作作用或者是目的。那么这样呢，就导致说subject你可以写的很灵活。然后呢，并且呢，可维护性非常强。目前的我们这边的，今天所说的代码呢，是说是不需要，完全不需要大家去理解的，只是说。通过大概跟大家说了一下这个拍了他的架构。然后呢，以及重点解释了一下这个config是有什么作用然后呢，给大家举了一个例子。让大家能感受到说subst在rust这么抽象强大的抽象能力的加持之下可以做到多通用以及多容易维护。