# 智能指针

指针是一个包含内存地址的变量。

智能指针实际上是一种结构体，它的行为类似指针，是对指针的一层封装，可以拥有元数据，并提供了额外的功能，比如自动释放堆内存。

## 独占所有权的 Box\<T\>

Box\<T\> 是指向类型为 T 的堆内存分配值的智能指针，可以通过解引用操作来获取 Box\<T\>中的 T。当 Box\<T\> 超出作用域范围时，Rust 会自动调用其析构函数，销毁内部对象，并释放所占的堆内存。

Box\<T\> 是独占所有权的智能指针，使用 Box::new 函数可以在堆上存储一个值，并把指向堆上数据的指针存放在栈上。

## 共享所有权的 Rc\<T\>
大部分情况下，所有权是明确的，我们可以准确地知道哪个变量拥有某个值，每个值都对应着一个所有者，只有拥有所有权才能释放资源。
但是，对于一些特殊的场景，某个值可能有多个所有者。
比如，在图数据结构中，多个边可能指向同一个节点，这个节点为所有指向它的边所拥有。在没有任何边指向它之前，这个节点都不应该被清理。
Rc\<T\> 允许一个值有多个所有者，引用计数确保了只要还存在所有者，该值就保持有效。每当值共享一个所有权时，计数就会增加一次。只有当计数为零，也就是当所有共享变量离开作用域时，该变量才会被析构。

## 应对内部可变性的 RefCell\<T\>
内部可变性是 Rust 的一种设计模式，它允许在不可变引用时也能改变数据。
Rust 的可变或不可变是针对变量绑定而言的，比如结构体的可变和不可变是指其实例的可变性，而不是某个字段的可变性。
Rust 提供了 RefCell\<T\>  来应对背部可变性模式，即值仍然是不可变的。外部的代码不能修改其值，但值的内部能够修改其自身。

RefCell\<T\> 常配合 Rc\<T\> 来使用。Rc\<T\> 允许数据有多个所有者，但只能提供数据的不可变引用。如果两者结合使用，Rc\<RefCell\<T\>\> 表面上是不可变的，但利用 RefCell\<T\> 的内部可变性可以在需要时修改数据。在树的数据结构中会有大量使用。

